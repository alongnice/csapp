# The Compilation System

## 编译流程

```mermaid
graph LR
A(预处理) --> B(编译) --> C(汇编) --> D(链接)
```

## 预处理(cpp)(pre-processor)

​		预处理器会根据 '#' 开头的内容修改原始代码

> hello文件,由于使用了stdio.h 的头文件,所以将会在此阶段读取到该头文件中的内容
>
> 并将其中内容直接插入到源程序中,从而形成一个新的c程序,一般以  .i  文件结尾 这里还是个文本文件

## 编译阶段(ccl)(compiler)

​		会将hello.i的文件转换成hello.s的文件的过程一般称之为编译

> 其中这一阶段要做到一下内容:
>
> 1. 词法分析
> 2. 语法分析
> 3. 语义分析
> 4. 中间代码生成
> 5. 优化操作
> 6. ....

​		此处细节需要去了解 编译原理  ,这一步得到的文件是   汇编文件

## 汇编阶段(as)(assembler)

​		汇编器,会根据汇编指令集将汇编程序翻译成机器指令,也就是我们常说的机器语言|二进制文件

> 并将上述机器指令所组成的文件按照固定规则进行打包
>
> 得到   可重定位 文件  但是当前文件不能直接运行

## 链接阶段(linker)(ld)

​		链接器负责将标准库或者第三方库,进行合并,以快速实现功能等...

> linux下的库分为动态库.o和静态库.so
>
> 非强制应用场景:
>
> ​		将部分内容的代码进行封装,方便调用或者对代码进行加密
> ​		提供给别人使用,但不想提供开源代码时可以使用,项目开发时,也需要用到其他人员编写的库
>
> 
>
> 动态库特点:
>
> 1. 库的内容不会被编译进入程序,产生的优势时程序比较小
> 2. 如果库文件未在环境中,那么缺少以来将不能运行
>
> 静态库特点:
>
> 1. 程序会被编译进入程序,程序故此程序会略大
> 2. 可以不依附于系统中的环境,缺少也可以运行,对待

​		例如 hello.o  和 printf.o 的合并 会需要一定规则,所以 汇编阶段输出的内容是 可重定位文件





## 为什么要理解编译器是如何工作的

1. optimizing program performance (优化程序的性能)

   > 一个switch语法是不是要比一连串的if-else高效?
   >
   > 答:
   >
   > 一个函数调用的开销有多大?
   >
   > 答:
   >
   > while循环比for循环更加高效嘛/
   >
   > 答:

2. understanding link-time errors (理解链接时出现的错误)

   > 大型项目会涉及到很多函数库的调用,往往会在链接部分出错,特别是一些链接错误会在程序运行时候才会出现
   >
   > 如何理解链接器报告无法解析的引用?
   >
   > 答:链接阶段访问了无法访问的私有变量.
   >
   > 
   >
   > 静态变量和全局变量的区别是什么?
   >
   > 答:
   >
   > 
   >
   > 不同的c文件中定义了名字相同的两个全局变量会怎么样?
   >
   > 答:优先考虑强弱关系,以强为主淡化弱,如果强度相同则直接报错.
   >
   > 
   >
   > 动态库与静态库的区别?
   >
   > 答:静态库(装载式链接) 在编译阶段将需要链接的共享库等二进制文件进行拷贝链接 故将时间成本转移到了编译时,运行时速度会更快,运行时缺少该共享库也不会影响程序运行
   >
   > ​	动态库(动态式链接) 在编译阶段不需要将全部二进制文件都拷贝进入可执行文件,而是仅仅添加重定位和符号等信息,在运行过程进行调用,相对应的运行程序时,共享库的缺失会影响程序运行
   >
   > ​		动态库关系查询命令: ldd <可执行程序>
   >
   > ```bash
   > $ ldd main
   >     linux-vdso.so.1 =>  (0x00007ffc7b5a2000)
   >     libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007fe9642bf000)
   >     libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe963ef5000)
   >     /lib64/ld-linux-x86-64.so.2 (0x00007fe9645c8000)
   > ```
   >
   > 命令行编译时排列库的顺序是否有那些影响?
   >
   > 为什么有些链接错误会在运行时才会出现?
   >
   > 答:动态链接,由于链接阶段只添加了部分动态库中的数据,可能导致运行时才会发生报错的现象. 

   

3. avoiding security holes (避免安全漏洞)

   > 缓冲区溢出(buffer overflow) 
   >
   > 防止安全漏洞
   >
   > 1. 理解数据和控制信息在程序栈上是如何存储的
   > 2. 了解不严谨不规范的书写方式是引起什么样的后果
   > 3. 第三章 讲述堆栈的原理和缓冲区溢出错误
   > 4. 如何利用操作系统,编译器来降低攻击的风险




## 系统的硬件组成

![img](https://gblobscdn.gitbook.com/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHzautgnqCcwmhp1v0t%2F-MHzbJTPxV8WF5Cpigw-%2F01-04%20system%20hardwares.png?alt=media&token=78949ed7-8d53-4392-b21d-e6123cd2dc50)

### 1. 总线

> 好比是道路,数据传输的道路,那么就会有多少条车道,路有多宽能一下传输多少内容(字节数;字长)

### 2.i/o设备

> 输入/输出设备,键盘鼠标,显示器,磁盘,  他们统统与控制器或者适配器连接进入总现,主要区别方式是封装方式的不同(也就是驱动的意义),网络设备一种特殊的io设备

### 3. 主存

> 临时存储设备,用于存放程序和程序需要处理的数据,就是干活的,一般由多个 动态随机存取存储器(DRAM)芯片组成, 暂且理解为内存条上的闪存芯片,在系统中会被抽象为一个线性字节数组.这些地址从0开始
>
> 暂时理解c语言中的指针就是在说这些地址,还没有验证

### 4. 处理器

> 中央处理单元(CPU) 


















# The Compilation System

## 编译流程

```mermaid
graph LR
A(预处理) --> B(编译) --> C(汇编) --> D(链接)
```

## 预处理(cpp)(pre-processor)

​		预处理器会根据 '#' 开头的内容修改原始代码

> hello文件,由于使用了stdio.h 的头文件,所以将会在此阶段读取到该头文件中的内容
>
> 并将其中内容直接插入到源程序中,从而形成一个新的c程序,一般以  .i  文件结尾 这里还是个文本文件

## 编译阶段(ccl)(compiler)

​		会将hello.i的文件转换成hello.s的文件的过程一般称之为编译

> 其中这一阶段要做到一下内容:
>
> 1. 词法分析
> 2. 语法分析
> 3. 语义分析
> 4. 中间代码生成
> 5. 优化操作
> 6. ....

​		此处细节需要去了解 编译原理  ,这一步得到的文件是   汇编文件

## 汇编阶段(as)(assembler)

​		汇编器,会根据汇编指令集将汇编程序翻译成机器指令,也就是我们常说的机器语言|二进制文件

> 并将上述机器指令所组成的文件按照固定规则进行打包
>
> 得到   可重定位 文件  但是当前文件不能直接运行

## 链接阶段(linker)(ld)

​		链接器负责将标准库或者第三方库,进行合并,以快速实现功能等...

> linux下的库分为动态库.o和静态库.so
>
> 非强制应用场景:
>
> ​		将部分内容的代码进行封装,方便调用或者对代码进行加密
> ​		提供给别人使用,但不想提供开源代码时可以使用,项目开发时,也需要用到其他人员编写的库
>
> 
>
> 动态库特点:
>
> 1. 库的内容不会被编译进入程序,产生的优势时程序比较小
> 2. 如果库文件未在环境中,那么缺少以来将不能运行
>
> 静态库特点:
>
> 1. 程序会被编译进入程序,程序故此程序会略大
> 2. 可以不依附于系统中的环境,缺少也可以运行,对待

​		例如 hello.o  和 printf.o 的合并 会需要一定规则,所以 汇编阶段输出的内容是 可重定位文件





## 为什么要理解编译器是如何工作的

1. optimizing program performance (优化程序的性能)

   > 一个switch语法是不是要比一连串的if-else高效?
   >
   > 答:
   >
   > 一个函数调用的开销有多大?
   >
   > 答:
   >
   > while循环比for循环更加高效嘛/
   >
   > 答:

2. understanding link-time errors (理解链接时出现的错误)

   > 大型项目会涉及到很多函数库的调用,往往会在链接部分出错,特别是一些链接错误会在程序运行时候才会出现
   >
   >
   > 静态变量和全局变量的区别是什么?

3. avoiding security holes (避免安全漏洞)

   > 缓冲区溢出(buffer overflow) 
   >
   > 防止安全漏洞
   >
   > 1. 理解数据和控制信息在程序栈上是如何存储的
   > 2. 了解不严谨不规范的书写方式是引起什么样的后果
   > 3. 第三章 讲述堆栈的原理和缓冲区溢出错误
   > 4. 如何利用操作系统,编译器来降低攻击的风险

4. 















